---
title: Tensorflow笔记
# description: 
date: 2018-09-12
# slug: 
# image: 
categories:
    - Tensorflow
---
#### TensorFolw 实战Google深度学习框架
用深度神经解决分类问题主要分为以下4个步骤：
1. 提取问题中实体的特征向量作为神经网络的输入
2. 定义神经网络结构，并定义如何从神经网络的输入得到输出
3. 训练神经网络，通过训练数据来调整神经网络中参数的取值
4. 使用训练好的神经网络来预测未知数据
5. 训练数据集、验证数据集、测试数据集最好来自于同一分布（训练集主要用户进行模型训练，验证集主要进行参数调整，测试集主要进行模型性能的评估） 
   

#####激活函数：
对于分类问题，现实中大部分数据都无法通过线性函数进行划分，使用激活函数实现去线性化，如：`ReLU(max(x,0))`函数，`sigmoid`函数，`tanh`函数。 

`sigmoid`函数和tanh函数很像，`sigmoid`函数使得函数输出范围在`[0, 1]`，左侧倒数从0开始趋向于0，容易造成梯度消失现象。而tanh函数的函数值域是`[-1, 1]`，特征相差明显时的效果会很好，在循环过程中会不断扩大特征效果。与 `sigmoid` 的区别是，`tanh` 是 0 均值的，因此实际应用中 `tanh` 会比`sigmoid` 更好。

#### 损失函数：
交叉熵用来判断一个输出向量和期望的向量有多接近，刻画了连个概率分布直接的距离，是分类问题中使用比较广泛的损失函数，给定两个概率分布：`p,q`交叉熵:
$$ H(p, q) = -∑ p(x) · log(q(x)) $$
 , 求和范围为所有$x$,通过最小化交叉熵，使得正确分类和预测分类的概率分布接近。 

在原有的输出层增加一个额外的处理层，可以将神经网络变成一个概率分布，原始神经网络的输出被用作置信度来生成新的输出。

分类问题：
经典损失函数：softmax，通过对原始输出层输出的数值进行求和，再用某一输出神经元的输出除以该和，得到预测值，所有输出神经元的预测值构成预测向量，再通过计算正确分类向量和预测向量的交叉熵，较小交叉熵的预测向量要优于较大交叉的预测向量

对于回归问题（具体数值的预测，一般只有一个输出神经元），最常用的损失函数是均方误差（MSE）
    
#### 神经网络优化算法：
梯度下降法和反向传播法：先通过前向传播法计算得到预测值，并比较预测值和真实值之间的差距，再用反向传播算法计算每一个参数的梯度，最后根据每个参数的梯度和学习率使用梯度下降法更新每一个参数  
学习率设置：使用TensorFlow的指数衰减法（tf.train.exponential_decay），用较大学习率快速得到一个比较优的解，随着迭代次数增加，逐步减少学习率，使得模型在训练后更加稳定

#### 过拟合问题：         
原因：1，训练数据太少；2，神经网络过于复杂。
解决办法: 

1. 正则化：在损失函数中加入刻画模型复杂度的指标。是模型的复杂度，λ是模型复杂损失在总损失中的比例。
$$ j'(θ) = j(θ) + λ · R(w)，R(w) $$
刻画模型复杂度的函数有两种，$w$为边上的权重，一是`L1`正则化：
$$R(w) = ||w||1 = ∑|wi|$$
二是L2正则化:
$$ R(w) = ||w||2 ^ 2 = ∑|wi ^ 2| $$
L1正则化不可导，L2正则化比较复杂，一般L1和L2同时使用:
$$ R(w) =∑ α · ||wi|| + (1 - α)  · wi ^ 2 $$
2. 使用dropout，dropout使得神经网络的部分神经元的权值等于0或者接近于0，相当于删除该神经元=简化神经网络。`tf.nn.dropout(layer,keep_prob )`，`keep_prob=1.0`表示该层的神经元100%工作


#### 滑动平均模型：
提高使用随机梯度下降法训练的神经网络模型在测试数据上的表现

   1. 深度神经网络（DNN）：
   即是最基本的多层全连接网络。前向传播法可以转化为基本的矩阵相乘来实现

   2. 循环神经网络（RNN）：
   当前状态的输出ot由当前状态的输入xt和上一时刻的隐含状态ht-1所决定的，在输出ot时，RNN还生成全新的隐含状态ht。常用沿时间反向传播训练方法对循环神经网络进行训练。

   3. 卷积神经网络（CNN）：
   解决全连接神经网络参数过多问题。一般组成：输入层->( 卷积层+  ->  池化层? )+ -> 全连接层+ -> 
   `softmax`层 -> 输出层。+表示一个或多个，?表示可有可无。加入池化层的作用是加快计算速度和防止过拟合（有研究指出加入池化层对模型效果影响不大，但主流CNN中一般都有池化层）。
   4. 卷积层过滤器：使用3x3或者5x5尺寸的过滤器进行前向传播运算，过滤器每次移动（tensorflowz中可设置移动步数）都生成一个固定深度的卷积层。卷积层中过滤器的参数是共享的，可以大幅减少神经网络上的参数。
   池化层：对卷积层进行分割，对分割的部分使用最大池化层或者平均池化层生成新的层。CNN比较适合处理图像，因为图像矩阵具有稠密性。高维、稀疏的向量不适合作为CNN的输入。 
   输入层是图像的像素点，且图片中的单个物体像素点是连续的，卷积核在输入层滑动时可以方便的提取到图片中的物体特征；另外，图片的像素点组成一个矩阵，这便于卷积核上下左右滑动提取特征。然而对于文本数据，文本中的词语却是离散的，比如“虽然……但是……”，这里“虽然”和“但是”显然具有关联的关系，但是它们之间却可能在句子中相隔很远，卷积核很难提取到这样的具有长距离依赖的词语之间的关系。
   卷积操作其实就是卷积核矩阵和对应的输入层中一小块矩阵的点积相乘，卷积核通过权重共享的方式，按照步幅上下左右的在输入层滑动提取特征，以此将输入层做特征映射（features map）作为输出层，但在 NLP 中，由于词嵌入层中每一行都表示一个词语，我们在句子里面提取有利于分类的特征肯定是需要从词语（word）或者字符（char）级别去提取，也就是卷积宽口的宽度应该覆盖完全单个词向量，也就是 CNN 的卷积核宽度必须要等于词向量的维度
   对于NPL，滑动窗口无法捕获远距离的特征

#### 自编码器（AE）：

#### 其它：
axis=0：矩阵的列
axis=1：矩阵的行